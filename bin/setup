#!/usr/bin/env ruby
require "fileutils"

APP_ROOT = File.expand_path("..", __dir__)

def system!(*args)
  system(*args, exception: true)
end

def print_header(message)
  puts "========================================"
  puts "#{message}"
  puts "========================================"
end

def print_success(message)
  puts "✓ #{message}"
end

def print_warning(message)
  puts "⚠️ #{message}"
end

def print_error(message)
  puts "❌ #{message}"
end

def print_info(message)
  puts "ℹ️ #{message}"
end

FileUtils.chdir APP_ROOT do
  # LETTERロゴ表示
  puts " ██╗      ███████╗ ████████╗ ████████╗ ███████╗ ██████╗"
  puts " ██║      ██╔════╝ ╚══██╔══╝ ╚══██╔══╝ ██╔════╝ ██╔══██╗"
  puts " ██║      █████╗      ██║       ██║    █████╗   ██████╔╝"
  puts " ██║      ██╔══╝      ██║       ██║    ██╔══╝   ██╔══██╗"
  puts " ███████╗ ███████╗    ██║       ██║    ███████╗ ██║  ██║"
  puts " ╚══════╝ ╚══════╝    ╚═╝       ╚═╝    ╚══════╝ ╚═╝  ╚═╝"
  puts ""
  
  print_header "letter セットアップスクリプト"
  print_info "実行時刻: #{Time.now}"

  # 1. 環境ファイルの設定
  print_info "1. 環境ファイルの確認..."
  env_template = <<~ENV
    # ========================================
    # 重要設定
    # ========================================

    # ActivityPub上で使用するドメインを設定します。一度使ったものは再利用できません
    ACTIVITYPUB_DOMAIN=your-domain.example.com

    # WebPushを有効化するために必要なVAPID
    VAPID_PUBLIC_KEY=your_vapid_public_key
    VAPID_PRIVATE_KEY=your_vapid_private_key

    # ActivityPubではHTTPSでなければ通信できません（ローカル開発時は空欄可）
    ACTIVITYPUB_PROTOCOL=

    # ========================================
    # オブジェクトストレージ設定
    # ========================================

    S3_ENABLED=false
    # S3_ENDPOINT=
    # S3_BUCKET=
    # R2_ACCESS_KEY_ID=
    # R2_SECRET_ACCESS_KEY=
    # S3_ALIAS_HOST=
  ENV

  if File.exist?(".env")
    print_success ".envファイルが存在します"
    
    # 必須項目のチェック
    env_content = File.read(".env")
    missing_keys = []
    
    %w[ACTIVITYPUB_DOMAIN VAPID_PUBLIC_KEY VAPID_PRIVATE_KEY].each do |key|
      unless env_content.match?(/^#{key}=.+/)
        missing_keys << key
      end
    end
    
    if missing_keys.any?
      print_warning "以下の必須設定が不足しています: #{missing_keys.join(', ')}"
      print_info "サンプル設定を .env.template として作成します"
      File.write(".env.template", env_template)
    else
      print_success "必須の環境変数が設定されています"
    end
  else
    print_warning ".envファイルが見つかりません。テンプレートを作成します"
    File.write(".env", env_template)
    print_info ".envファイルを作成しました。設定を編集してください:"
    print_info "  - ACTIVITYPUB_DOMAIN: あなたのドメイン"
    print_info "  - VAPID_PUBLIC_KEY/VAPID_PRIVATE_KEY: WebPush用キー"
    puts ""
    print_error "設定完了後、再度このスクリプトを実行してください"
    exit 1
  end

  # 2. 依存関係のインストール
  print_info "2. 依存関係のインストール..."
  system("bundle check") || system!("bundle install")
  print_success "依存関係をインストールしました"

  # 3. データベースの確認と準備
  print_info "3. データベースの確認と準備..."
  
  # データベースファイルの存在確認（SQLite用）
  if File.exist?("db/development.sqlite3")
    print_success "データベースファイルが存在します"
  else
    print_warning "データベースファイルが見つかりません。作成します..."
    begin
      system! "bin/rails db:create"
      print_success "データベースを作成しました"
    rescue => e
      print_error "データベース作成に失敗しました: #{e.message}"
      exit 1
    end
  end

  # マイグレーションの実行
  print_info "マイグレーションの確認..."
  
  # まずマイグレーション状態を確認
  migrate_output = `bin/rails db:migrate:status 2>&1`
  if $?.success?
    pending_migrations = migrate_output.lines.select { |line| line.include?("down") }
    
    if pending_migrations.empty?
      print_success "すべてのマイグレーションが完了しています"
    else
      print_info "#{pending_migrations.count}個の未実行マイグレーションがあります"
      
      # 通常のマイグレーションを試行
      if system("bin/rails db:migrate 2>/dev/null")
        print_success "マイグレーションを実行しました"
      else
        print_warning "マイグレーションでエラーが発生しましたが、続行します"
      end
    end
  else
    # マイグレーション状態確認に失敗した場合
    print_warning "マイグレーション状態の確認に失敗しました。スキップします"
  end

  # 4. ログとテンポラリファイルのクリーンアップ
  print_info "4. ログとテンポラリファイルのクリーンアップ..."
  system! "bin/rails log:clear tmp:clear"
  print_success "クリーンアップが完了しました"

  # 5. 既存プロセスの確認と停止
  print_info "5. 既存プロセスの確認..."
  rails_running = system("pgrep -f 'rails server' > /dev/null 2>&1")
  queue_running = system("pgrep -f 'solid.*queue' > /dev/null 2>&1")

  if rails_running || queue_running
    print_warning "既存のプロセスが動作中です。停止します..."
    system("pkill -f 'solid.*queue' 2>/dev/null || true")
    system("pkill -f 'rails server' 2>/dev/null || true")
    system("pkill -f 'puma.*pit1' 2>/dev/null || true")
    sleep 3
    print_success "既存プロセスを停止しました"
  end

  # PIDファイルのクリーンアップ
  print_info "PIDファイルのクリーンアップ..."
  FileUtils.rm_f("tmp/pids/server.pid")
  Dir.glob("tmp/pids/solid_queue*.pid").each { |f| FileUtils.rm_f(f) }

  unless ARGV.include?("--skip-server")
    # 6. 環境変数の読み込み
    print_info "6. 環境変数の読み込み..."
    if File.exist?("bin/load_env.sh")
      env_vars = {}
      File.readlines(".env").each do |line|
        line = line.strip
        next if line.empty? || line.start_with?("#")
        key, value = line.split("=", 2)
        env_vars[key] = value if key && value
      end
      
      required_vars = %w[ACTIVITYPUB_DOMAIN]
      missing_vars = required_vars.select { |var| env_vars[var].nil? || env_vars[var].empty? }
      
      if missing_vars.any?
        print_error "必須環境変数が設定されていません: #{missing_vars.join(', ')}"
        exit 1
      end
      
      print_success "環境変数を読み込みました"
      print_info "ACTIVITYPUB_DOMAIN: #{env_vars['ACTIVITYPUB_DOMAIN']}"
      print_info "ACTIVITYPUB_PROTOCOL: #{env_vars['ACTIVITYPUB_PROTOCOL'] || 'http (default)'}"
    end

    # 7. サーバの起動
    print_info "7. サーバの起動..."
    
    # Railsサーバを起動（デーモンモード）
    print_info "Railsサーバを起動中..."
    system!("RAILS_ENV=development rails server -b 0.0.0.0 -p 3000 -d")
    print_success "Railsサーバを起動しました"

    # Solid Queueを起動
    print_info "Solid Queueワーカーを起動中..."
    system("RAILS_ENV=development nohup bin/jobs > log/solid_queue.log 2>&1 &")
    print_success "Solid Queueワーカーを起動しました"

    # 8. 起動確認
    print_info "8. 起動確認中..."
    sleep 5

    # サーバの応答確認
    server_ok = system("curl -s http://localhost:3000 > /dev/null 2>&1")
    if server_ok
      print_success "Railsサーバが応答しています"
    else
      print_warning "Railsサーバの応答確認に失敗しました"
    end

    # プロセス数の確認
    rails_procs = `ps aux | grep -c '[r]ails server'`.to_i
    queue_procs = `ps aux | grep -c '[s]olid.*queue'`.to_i

    print_info "Railsプロセス数: #{rails_procs}"
    print_info "Solid Queueプロセス数: #{queue_procs}"

    # Solid Queueの動作確認
    if queue_procs > 0
      print_success "Solid Queueワーカーが動作中です"
      begin
        pending_jobs = `timeout 5 bin/rails runner "puts SolidQueue::Job.where(finished_at: nil).count" 2>/dev/null`.strip.to_i
        print_info "待機中ジョブ数: #{pending_jobs}"
      rescue
        print_warning "ジョブ状況確認がタイムアウトしました"
      end
    else
      print_error "Solid Queueワーカーが起動していません。手動で再起動してください:"
      print_info "  bin/jobs &"
    end

    # Solid Cableの動作確認
    print_info "Solid Cableの動作確認中..."
    begin
      cable_check = `timeout 5 bin/rails runner "
        adapter = ActionCable.server.config.cable&.[](:adapter) || 'unknown'
        puts 'adapter:' + adapter.to_s
        
        if adapter.to_s == 'solid_cable'
          begin
            ActiveRecord::Base.establish_connection(:cable)
            if ActiveRecord::Base.connection.table_exists?('solid_cable_messages')
              message_count = ActiveRecord::Base.connection.execute('SELECT COUNT(*) FROM solid_cable_messages').first[0]
              puts 'messages:' + message_count.to_s
              puts 'status:ok'
            else
              puts 'status:no_table'
            end
          rescue => e
            puts 'status:error:' + e.message
          ensure
            ActiveRecord::Base.establish_connection(:primary)
          end
        else
          puts 'status:unused'
        end
      " 2>/dev/null`.strip

      cable_lines = cable_check.split("\n")
      adapter = cable_lines.find { |l| l.start_with?("adapter:") }&.sub("adapter:", "")
      status = cable_lines.find { |l| l.start_with?("status:") }&.sub("status:", "")
      
      case status
      when "ok"
        message_count = cable_lines.find { |l| l.start_with?("messages:") }&.sub("messages:", "")
        print_success "Solid Cable が正常動作中 (messages: #{message_count})"
      when "no_table"
        print_warning "Solid Cable テーブルが見つかりません"
      when /^error:/
        error_msg = status.sub("error:", "")
        print_warning "Solid Cable 接続エラー: #{error_msg}"
      when "unused"
        print_info "Solid Cable は未使用 (adapter: #{adapter})"
      else
        print_warning "Solid Cable 確認結果が不明です"
      end
    rescue
      print_warning "Solid Cable確認がタイムアウトしました"
    end

    # 最終結果表示
    puts ""
    print_header "セットアップ完了"
    print_success "letter が正常に起動しました"
    
    domain = env_vars&.dig('ACTIVITYPUB_DOMAIN') || 'localhost'
    protocol = env_vars&.dig('ACTIVITYPUB_PROTOCOL') || 'http'
    
    print_info "アクセス情報:"
    puts "  ローカルURL: http://localhost:3000"
    puts "  公開URL: #{protocol}://#{domain}" if domain != 'localhost'
    puts ""
    print_info "監視コマンド:"
    puts "  tail -f log/development.log"
    puts "  tail -f log/solid_queue.log"
    puts "  ps aux | grep -E 'rails|solid'"
    puts ""
    print_info "停止コマンド:"
    puts "  pkill -f 'rails server|solid.*queue'"
  else
    print_success "サーバの起動をスキップしました (--skip-server)"
  end
end
